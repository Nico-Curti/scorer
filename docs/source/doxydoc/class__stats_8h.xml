<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="class__stats_8h" kind="file" language="C++">
    <compoundname>class_stats.h</compoundname>
    <includes refid="common__stats_8h" local="no">common_stats.h</includes>
    <incdepgraph>
      <node id="9">
        <label>cmath</label>
      </node>
      <node id="10">
        <label>cassert</label>
      </node>
      <node id="5">
        <label>numeric</label>
      </node>
      <node id="2">
        <label>common_stats.h</label>
        <link refid="common__stats_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>/home/nico/Code/scorer/include/class_stats.h</label>
        <link refid="class__stats_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>vector</label>
      </node>
      <node id="8">
        <label>climits</label>
      </node>
      <node id="7">
        <label>set</label>
      </node>
      <node id="4">
        <label>algorithm</label>
      </node>
      <node id="3">
        <label>memory</label>
      </node>
    </incdepgraph>
      <sectiondef kind="var">
      <memberdef kind="variable" id="class__stats_8h_1a4f571c2867f0b5a5071d4baf8a3537b7" prot="public" static="no" mutable="no">
        <type>struct @0</type>
        <definition>struct @0 get_TOP</definition>
        <argsstring></argsstring>
        <name>get_TOP</name>
        <briefdescription>
<para>Number of positive outcomes. </para>
        </briefdescription>
        <detaileddescription>
<para><programlisting filename=".python"><codeline><highlight class="normal">TOP<sp/>=<sp/>TP<sp/>+<sp/>FP</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of the number of positives outcomes for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="28" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1ae2a524794da550c05f8e4b8b6c76ab71" prot="public" static="no" mutable="no">
        <type>struct @1</type>
        <definition>struct @1 get_TON</definition>
        <argsstring></argsstring>
        <name>get_TON</name>
        <briefdescription>
<para>Number of negative outcomes. </para>
        </briefdescription>
        <detaileddescription>
<para><programlisting filename=".python"><codeline><highlight class="normal">TON<sp/>=<sp/>TN<sp/>+<sp/>FN</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negatives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of the number of negative outcomes for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="52" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a3804210e6ecc00435597d154be2ce4e2" prot="public" static="no" mutable="no">
        <type>struct @2</type>
        <definition>struct @2 get_TPR</definition>
        <argsstring></argsstring>
        <name>get_TPR</name>
        <briefdescription>
<para>True positive rates. </para>
        </briefdescription>
        <detaileddescription>
<para>Sensitivity (also called the true positive rate, the recall, or probability of detection in some fields) measures the proportion of positives that are correctly identified as such (e.g. the percentage of sick people who are correctly identified as having the condition)</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">TPR<sp/>=<sp/>TP<sp/>/<sp/>P<sp/>=<sp/>TP<sp/>/<sp/>(TP<sp/>+<sp/>FN)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of the true positive rate outcomes for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="80" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a834276bf2047f892965a07ddab5465f4" prot="public" static="no" mutable="no">
        <type>struct @3</type>
        <definition>struct @3 get_TNR</definition>
        <argsstring></argsstring>
        <name>get_TNR</name>
        <briefdescription>
<para>True negative rates. </para>
        </briefdescription>
        <detaileddescription>
<para>Specificity (also called the true negative rate) measures the proportion of negatives that are correctly identified as such (e.g. the percentage of healthy people who are correctly identified as not having the condition)</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">TPN<sp/>=<sp/>TN<sp/>/<sp/>N<sp/>=<sp/>TN<sp/>/<sp/>(TN<sp/>+<sp/>FP)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negatives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of the true negative rate outcomes for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="108" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1ae0aa1ab53c1315a74412b550b5bed0f0" prot="public" static="no" mutable="no">
        <type>struct @4</type>
        <definition>struct @4 get_PPV</definition>
        <argsstring></argsstring>
        <name>get_PPV</name>
        <briefdescription>
<para>Positive predictive value. </para>
        </briefdescription>
        <detaileddescription>
<para>Positive predictive value (PPV) is the proportion of positives that correspond to the presence of the condition</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">PPV<sp/>=<sp/>TP<sp/>/<sp/>(TP<sp/>+<sp/>FP)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of the positive predicted values for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="134" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1ae2a82ae30d655bd5724e7497947cc478" prot="public" static="no" mutable="no">
        <type>struct @5</type>
        <definition>struct @5 get_NPV</definition>
        <argsstring></argsstring>
        <name>get_NPV</name>
        <briefdescription>
<para>Negative predictive value. </para>
        </briefdescription>
        <detaileddescription>
<para>Negative predictive value (NPV) is the proportion of negatives that correspond to the absence of the condition</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">NPV<sp/>=<sp/>TN<sp/>/<sp/>(TN<sp/>+<sp/>FN)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negatives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negatives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of the negative predicted values for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="160" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a088799efa94fcd27f75777d228d89f58" prot="public" static="no" mutable="no">
        <type>struct @6</type>
        <definition>struct @6 get_FNR</definition>
        <argsstring></argsstring>
        <name>get_FNR</name>
        <briefdescription>
<para>False negative rate. </para>
        </briefdescription>
        <detaileddescription>
<para>The false negative rate is the proportion of positives which yield negative test outcomes with the test, i.e., the conditional probability of a negative test result given that the condition being looked for is present.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">FNR<sp/>=<sp/>FN<sp/>/<sp/>P<sp/>=<sp/>FN<sp/>/<sp/>(FN<sp/>+<sp/>TP)<sp/>=<sp/>1<sp/>-<sp/>TPR</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of the false negative rates for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="186" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1aca584c48b01afddfc7e4a5932a221f1f" prot="public" static="no" mutable="no">
        <type>struct @7</type>
        <definition>struct @7 get_FPR</definition>
        <argsstring></argsstring>
        <name>get_FPR</name>
        <briefdescription>
<para>False positive rate. </para>
        </briefdescription>
        <detaileddescription>
<para>The false positive rate is the proportion of all negatives that still yield positive test outcomes, i.e., the conditional probability of a positive test result given an event that was not present. The false positive rate is equal to the significance level. The specificity of the test is equal to 1 minus the false positive rate.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">FPR<sp/>=<sp/>FP<sp/>/<sp/>N<sp/>=<sp/>FP<sp/>/<sp/>(FP<sp/>+<sp/>TN)<sp/>=<sp/>1<sp/>-<sp/>TNR</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negative rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of the false positive rates for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="214" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1ad8dbeb51e4bd0879ebe897b098892309" prot="public" static="no" mutable="no">
        <type>struct @8</type>
        <definition>struct @8 get_FDR</definition>
        <argsstring></argsstring>
        <name>get_FDR</name>
        <briefdescription>
<para>False discovery rate. </para>
        </briefdescription>
        <detaileddescription>
<para>The false discovery rate (FDR) is a method of conceptualizing the rate of type I errors in null hypothesis testing when conducting multiple comparisons. FDR-controlling procedures are designed to control the expected proportion of &quot;discoveries&quot; (rejected null hypotheses) that are false (incorrect rejections).</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">FDR<sp/>=<sp/>FP<sp/>/<sp/>(FP<sp/>+<sp/>TP)<sp/>=<sp/>1<sp/>-<sp/>PPV</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>PPV</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predictive values </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of the false discovery rates for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="242" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1ad66d23a797168b8d1ae7c9be7c2aeb85" prot="public" static="no" mutable="no">
        <type>struct @9</type>
        <definition>struct @9 get_FOR</definition>
        <argsstring></argsstring>
        <name>get_FOR</name>
        <briefdescription>
<para>False omission rate. </para>
        </briefdescription>
        <detaileddescription>
<para>False omission rate (FOR) is a statistical method used in multiple hypothesis testing to correct for multiple comparisons and it is the complement of the negative predictive value. It measures the proportion of false negatives which are incorrectly rejected.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">FOR<sp/>=<sp/>FN<sp/>/<sp/>(FN<sp/>+<sp/>TN)<sp/>=<sp/>1<sp/>-<sp/>NPV</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>NPV</parametername>
</parameternamelist>
<parameterdescription>
<para>array of negative predictive values </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of the false omission rates for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="269" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1aca1effd3fe98d13cfd3840068136dcc7" prot="public" static="no" mutable="no">
        <type>struct @10</type>
        <definition>struct @10 get_ACC</definition>
        <argsstring></argsstring>
        <name>get_ACC</name>
        <briefdescription>
<para>Accuracy. </para>
        </briefdescription>
        <detaileddescription>
<para>The accuracy is the number of correct predictions from all predictions made.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">ACC<sp/>=<sp/>(TP<sp/>+<sp/>TN)<sp/>/<sp/>(P<sp/>+<sp/>N)<sp/>=<sp/>(TP<sp/>+<sp/>TN)<sp/>/<sp/>(TP<sp/>+<sp/>TN<sp/>+<sp/>FP<sp/>+<sp/>FN)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negatives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of accuracies for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="298" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1ac498b4ad6fc24bbe00ad0a3ece250085" prot="public" static="no" mutable="no">
        <type>struct @11</type>
        <definition>struct @11 get_F1_SCORE</definition>
        <argsstring></argsstring>
        <name>get_F1_SCORE</name>
        <briefdescription>
<para>Fβ-score. </para>
        </briefdescription>
        <detaileddescription>
<para>In statistical analysis of classification, the F1 score (also F-score or F-measure) is a measure of a test&apos;s accuracy. It considers both the precision p and the recall r of the test to compute the score. The F1 score is the harmonic average of the precision and recall, where F1 score reaches its best value at 1 (perfect precision and recall) and worst at 0. In this case the score is evaluated with β=1.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">Fβ<sp/>=<sp/>(1<sp/>+<sp/>β**2)<sp/>*<sp/>(PPV<sp/>*<sp/>TPR)<sp/>/<sp/>(β**2<sp/>*<sp/>PPV)<sp/>+<sp/>TPR<sp/>=<sp/>(1<sp/>+<sp/>β**2)<sp/>*<sp/>TP<sp/>/<sp/>((1<sp/>+<sp/>β**2)<sp/>*<sp/>TP<sp/>+<sp/>FP<sp/>+<sp/>β**2<sp/>*<sp/>FN)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of F1 scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="332" column="14"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a09f8b8bdbc942775a7266d8f859e3436" prot="public" static="no" mutable="no">
        <type>struct @12</type>
        <definition>struct @12 get_F05_SCORE</definition>
        <argsstring></argsstring>
        <name>get_F05_SCORE</name>
        <briefdescription>
<para>Fβ-score. </para>
        </briefdescription>
        <detaileddescription>
<para>In statistical analysis of classification, the F1 score (also F-score or F-measure) is a measure of a test&apos;s accuracy. It considers both the precision p and the recall r of the test to compute the score. The F1 score is the harmonic average of the precision and recall, where F1 score reaches its best value at 1 (perfect precision and recall) and worst at 0. In this case the score is evaluated with β=0.5.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">Fβ<sp/>=<sp/>(1<sp/>+<sp/>β**2)<sp/>*<sp/>(PPV<sp/>*<sp/>TPR)<sp/>/<sp/>(β**2<sp/>*<sp/>PPV)<sp/>+<sp/>TPR<sp/>=<sp/>(1<sp/>+<sp/>β**2)<sp/>*<sp/>TP<sp/>/<sp/>((1<sp/>+<sp/>β**2)<sp/>*<sp/>TP<sp/>+<sp/>FP<sp/>+<sp/>β**2<sp/>*<sp/>FN)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of F1 scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="366" column="15"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a9dc5ed5df7ab3ca27584cceec3fdf11a" prot="public" static="no" mutable="no">
        <type>struct @13</type>
        <definition>struct @13 get_F2_SCORE</definition>
        <argsstring></argsstring>
        <name>get_F2_SCORE</name>
        <briefdescription>
<para>Fβ-score. </para>
        </briefdescription>
        <detaileddescription>
<para>In statistical analysis of classification, the F1 score (also F-score or F-measure) is a measure of a test&apos;s accuracy. It considers both the precision p and the recall r of the test to compute the score. The F1 score is the harmonic average of the precision and recall, where F1 score reaches its best value at 1 (perfect precision and recall) and worst at 0. In this case the score is evaluated with β=2.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">Fβ<sp/>=<sp/>(1<sp/>+<sp/>β**2)<sp/>*<sp/>(PPV<sp/>*<sp/>TPR)<sp/>/<sp/>(β**2<sp/>*<sp/>PPV)<sp/>+<sp/>TPR<sp/>=<sp/>(1<sp/>+<sp/>β**2)<sp/>*<sp/>TP<sp/>/<sp/>((1<sp/>+<sp/>β**2)<sp/>*<sp/>TP<sp/>+<sp/>FP<sp/>+<sp/>β**2<sp/>*<sp/>FN)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of F1 scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="400" column="14"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1aa9c90387d1ddb6f26781c723b8a9465e" prot="public" static="no" mutable="no">
        <type>struct @14</type>
        <definition>struct @14 get_MCC</definition>
        <argsstring></argsstring>
        <name>get_MCC</name>
        <briefdescription>
<para>Matthews correlation coefficient. </para>
        </briefdescription>
        <detaileddescription>
<para>The Matthews correlation coefficient is used in machine learning as a measure of the quality of binary (two-class) classifications, introduced by biochemist Brian W. Matthews in 1975. It takes into account true and false positives and negatives and is generally regarded as a balanced measure that can be used even if the classes are of very different sizes. The MCC is, in essence, a correlation coefficient between the observed and predicted binary classifications; it returns a value between −1 and +1. A coefficient of +1 represents a perfect prediction, 0 no better than random prediction and −1 indicates total disagreement between prediction and observation.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">MCC<sp/>=<sp/>(TP<sp/>*<sp/>TN<sp/>-<sp/>FP<sp/>*<sp/>FN)<sp/>/<sp/>sqrt((TP<sp/>+<sp/>FP)<sp/>*<sp/>(TP<sp/>+<sp/>FN)<sp/>*<sp/>(TN<sp/>+<sp/>FP)<sp/>*<sp/>(TN<sp/>+<sp/>FN))</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negatives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of MCC scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="436" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1abe903bf400b3d634f70419a2168499c1" prot="public" static="no" mutable="no">
        <type>struct @15</type>
        <definition>struct @15 get_BM</definition>
        <argsstring></argsstring>
        <name>get_BM</name>
        <briefdescription>
<para>Bookmaker informedness. </para>
        </briefdescription>
        <detaileddescription>
<para>The informedness of a prediction method as captured by a contingency matrix is defined as the probability that the prediction method will make a correct decision as opposed to guessing and is calculated using the bookmaker algorithm. It is equal to Youden Index.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">BM<sp/>=<sp/>TPR<sp/>+<sp/>TNR<sp/>-<sp/>1</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negative rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of BM scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="464" column="8"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a25fc19b5601dba9de79540d1639d0aea" prot="public" static="no" mutable="no">
        <type>struct @16</type>
        <definition>struct @16 get_MK</definition>
        <argsstring></argsstring>
        <name>get_MK</name>
        <briefdescription>
<para>Markedness. </para>
        </briefdescription>
        <detaileddescription>
<para>In statistics and psychology, the social science concept of markedness is quantified as a measure of how much one variable is marked as a predictor or possible cause of another and is also known as △P in simple two-choice cases.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">MK<sp/>=<sp/>PPV<sp/>+<sp/>NPV<sp/>-<sp/>1</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>PPV</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predictive values </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NPV</parametername>
</parameternamelist>
<parameterdescription>
<para>array of negative predictive values </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of MK scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="491" column="8"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a437422d689c8d462703adcf98784eb0b" prot="public" static="no" mutable="no">
        <type>struct @17</type>
        <definition>struct @17 get_ICSI</definition>
        <argsstring></argsstring>
        <name>get_ICSI</name>
        <briefdescription>
<para>Individual classification success index. </para>
        </briefdescription>
        <detaileddescription>
<para>The Individual Classification Success Index (ICSI), is a class-specific symmetric measure defined for classification assessment purpose. ICSI is hence 1 minus the sum of type I and type II errors. It ranges from −1 (both errors are maximal, i.e. 1) to 1 (both errors are minimal, i.e. 0), but the value 0 does not have any clear meaning. The measure is symmetric, and linearly related to the arithmetic mean of TPR and PPV</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">ICSI<sp/>=<sp/>PPV<sp/>+<sp/>TPR<sp/>-<sp/>1</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>PPV</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predictive values </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of ICSI for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="521" column="10"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a0d9856733d36e2d842f94df49d38faf2" prot="public" static="no" mutable="no">
        <type>struct @18</type>
        <definition>struct @18 get_PLR</definition>
        <argsstring></argsstring>
        <name>get_PLR</name>
        <briefdescription>
<para>Positive likelihood ratio. </para>
        </briefdescription>
        <detaileddescription>
<para>Likelihood ratios are used for assessing the value of performing a diagnostic test. They use the sensitivity and specificity of the test to determine whether a test result usefully changes the probability that a condition (such as a disease state) exists. The first description of the use of likelihood ratios for decision rules was made at a symposium on information theory in 1954.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">PLR<sp/>=<sp/>TPR<sp/>/<sp/>FPR</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positive rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of TPR for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="550" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1aad5d70ce26c5acd55bd3e02605136d9c" prot="public" static="no" mutable="no">
        <type>struct @19</type>
        <definition>struct @19 get_NLR</definition>
        <argsstring></argsstring>
        <name>get_NLR</name>
        <briefdescription>
<para>Negative likelihood ratio. </para>
        </briefdescription>
        <detaileddescription>
<para>Likelihood ratios are used for assessing the value of performing a diagnostic test. They use the sensitivity and specificity of the test to determine whether a test result usefully changes the probability that a condition (such as a disease state) exists. The first description of the use of likelihood ratios for decision rules was made at a symposium on information theory in 1954.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">NLR<sp/>=<sp/>FNR<sp/>/<sp/>TNR</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>FNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negative rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of NLR for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="579" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a4d3758db8977cff40410599faa8f756c" prot="public" static="no" mutable="no">
        <type>struct @20</type>
        <definition>struct @20 get_DOR</definition>
        <argsstring></argsstring>
        <name>get_DOR</name>
        <briefdescription>
<para>Diagnostic odds ratio. </para>
        </briefdescription>
        <detaileddescription>
<para>The diagnostic odds ratio is a measure of the effectiveness of a diagnostic test. It is defined as the ratio of the odds of the test being positive if the subject has a disease relative to the odds of the test being positive if the subject does not have the disease.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">DOR<sp/>=<sp/>PLR<sp/>/<sp/>NLR</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>PLR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive likelihood ratio values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>NLR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of negative likelihood ratio values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of DOR scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="607" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a406539d7361740226dd168817d6a226d" prot="public" static="no" mutable="no">
        <type>struct @21</type>
        <definition>struct @21 get_PRE</definition>
        <argsstring></argsstring>
        <name>get_PRE</name>
        <briefdescription>
<para>Prevalence. </para>
        </briefdescription>
        <detaileddescription>
<para>Prevalence is a statistical concept referring to the number of cases of a disease that are present in a particular population at a given time (Reference Likelihood).</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">PRE<sp/>=<sp/>P<sp/>/<sp/>POP</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>array of the number of positive samples for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>POP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of total samples for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of PRE scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="634" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a7f628f8c8883b51763d734ffe8cf6d23" prot="public" static="no" mutable="no">
        <type>struct @22</type>
        <definition>struct @22 get_G</definition>
        <argsstring></argsstring>
        <name>get_G</name>
        <briefdescription>
<para>G-measure. </para>
        </briefdescription>
        <detaileddescription>
<para>The geometric mean of precision and sensitivity, also known as Fowlkes–Mallows index.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">G<sp/>=<sp/>sqrt(PPV<sp/>*<sp/>TPR)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>PPV</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predicted values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of G scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="660" column="7"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a764a34712459bbc30493529dcb0dd851" prot="public" static="no" mutable="no">
        <type>struct @23</type>
        <definition>struct @23 get_RACC</definition>
        <argsstring></argsstring>
        <name>get_RACC</name>
        <briefdescription>
<para>Random accuracy. </para>
        </briefdescription>
        <detaileddescription>
<para>The expected accuracy from a strategy of randomly guessing categories according to reference and response distributions.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">RACC<sp/>=<sp/>(TOP<sp/>*<sp/>P)<sp/>/<sp/>POP**2</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TOP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predicted values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>POP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of RACC scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="688" column="10"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1af5aa85580b48b241cc4454b2f055a569" prot="public" static="no" mutable="no">
        <type>struct @24</type>
        <definition>struct @24 get_ERR_ACC</definition>
        <argsstring></argsstring>
        <name>get_ERR_ACC</name>
        <briefdescription>
<para>Error rate. </para>
        </briefdescription>
        <detaileddescription>
<para>The error rate is the number of incorrect predictions from all predictions made.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">ERR<sp/>=<sp/>(FP<sp/>+<sp/>FN)<sp/>/<sp/>(P<sp/>+<sp/>N)<sp/>=<sp/>(FP<sp/>+<sp/>FN)<sp/>/<sp/>(TP<sp/>+<sp/>TN<sp/>+<sp/>FP<sp/>+<sp/>FN)<sp/>=<sp/>1<sp/>-<sp/>ACC</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ACC</parametername>
</parameternamelist>
<parameterdescription>
<para>array of accuracy scores for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of error rates for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="712" column="13"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a491666a86299e747c43a6a9f25b74f70" prot="public" static="no" mutable="no">
        <type>struct @25</type>
        <definition>struct @25 get_RACCU</definition>
        <argsstring></argsstring>
        <name>get_RACCU</name>
        <briefdescription>
<para>Random accuracy unbiased. </para>
        </briefdescription>
        <detaileddescription>
<para>The expected accuracy from a strategy of randomly guessing categories according to the average of the reference and response distributions.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">RACCU<sp/>=<sp/>((TOP<sp/>+<sp/>P)<sp/>/<sp/>(2<sp/>*<sp/>POP))**2</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TOP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predicted values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>POP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of RACCU scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="740" column="11"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a7aea102ac6ce28d17c10ffbdc43bb0fa" prot="public" static="no" mutable="no">
        <type>struct @26</type>
        <definition>struct @26 get_jaccard_index</definition>
        <argsstring></argsstring>
        <name>get_jaccard_index</name>
        <briefdescription>
<para>Jaccard index. </para>
        </briefdescription>
        <detaileddescription>
<para>The Jaccard index, also known as Intersection over Union and the Jaccard similarity coefficient (originally coined coefficient de communauté by Paul Jaccard), is a statistic used for comparing the similarity and diversity of sample sets.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">J<sp/>=<sp/>TP<sp/>/<sp/>(TOP<sp/>+<sp/>P<sp/>-<sp/>TP)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TOP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predicted values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of J scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="770" column="19"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a86f8345d5a0ecda157ccd993f3833c46" prot="public" static="no" mutable="no">
        <type>struct @27</type>
        <definition>struct @27 get_IS</definition>
        <argsstring></argsstring>
        <name>get_IS</name>
        <briefdescription>
<para>Information score. </para>
        </briefdescription>
        <detaileddescription>
<para>The amount of information needed to correctly classify an example into class C, whose prior probability is p(C), is defined as −log2⁡(p(C)).</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">IS<sp/>=<sp/>-log2(<sp/>(TP<sp/>+<sp/>FN)/POP<sp/>)<sp/>+<sp/>log2(<sp/>TP<sp/>/<sp/>(TP<sp/>+<sp/>FP))</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positive values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>POP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of IS scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="799" column="8"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a639fe3a8c1c48a2d97b9a8b023275faa" prot="public" static="no" mutable="no">
        <type>struct @28</type>
        <definition>struct @28 get_CEN</definition>
        <argsstring></argsstring>
        <name>get_CEN</name>
        <briefdescription>
<para>Confusion entropy. </para>
        </briefdescription>
        <detaileddescription>
<para>CEN based upon the concept of entropy for evaluating classifier performances. By exploiting the misclassification information of confusion matrices, the measure evaluates the confusion level of the class distribution of misclassified samples. Both theoretical analysis and statistical results show that the proposed measure is more discriminating than accuracy and RCI while it remains relatively consistent with the two measures. Moreover, it is more capable of measuring how the samples of different classes have been separated from each other. Hence the proposed measure is more precise than the two measures and can substitute for them to evaluate classifiers in classification applications.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>confusion_matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>confusion matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of CEN for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="852" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a967a674734a10321891a32db5d1f4aec" prot="public" static="no" mutable="no">
        <type>struct @29</type>
        <definition>struct @29 get_MCEN</definition>
        <argsstring></argsstring>
        <name>get_MCEN</name>
        <briefdescription>
<para>Modified confusion entropy. </para>
        </briefdescription>
        <detaileddescription>
<para>Modified version of CEN</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>confusion_matrix</parametername>
</parameternamelist>
<parameterdescription>
<para>confusion matrix. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of MCEN for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="897" column="10"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a85e0fa3f6dc1addfb5595f8c202597cc" prot="public" static="no" mutable="no">
        <type>struct @30</type>
        <definition>struct @30 get_AUC</definition>
        <argsstring></argsstring>
        <name>get_AUC</name>
        <briefdescription>
<para>Area under the ROC curve. </para>
        </briefdescription>
        <detaileddescription>
<para>The area under the curve (often referred to as simply the AUC) is equal to the probability that a classifier will rank a randomly chosen positive instance higher than a randomly chosen negative one (assuming &apos;positive&apos; ranks higher than &apos;negative&apos;). Thus, AUC corresponds to the arithmetic mean of sensitivity and specificity values of each class.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">AUC<sp/>=<sp/>(TNR<sp/>+<sp/>TPR)<sp/>/<sp/>2</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negative rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of AUC for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="928" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1ab216c2990c8cbd60104ae5fbf6c64319" prot="public" static="no" mutable="no">
        <type>struct @31</type>
        <definition>struct @31 get_dIND</definition>
        <argsstring></argsstring>
        <name>get_dIND</name>
        <briefdescription>
<para>Distance index. </para>
        </briefdescription>
        <detaileddescription>
<para>Euclidean distance of a ROC point from the top left corner of the ROC space, which can take values between 0 (perfect classification) and sqrt(2).</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">dInd<sp/>=<sp/>sqrt((1<sp/>-<sp/>TNR)**2<sp/>+<sp/>(1<sp/>-<sp/>TPR)**2)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negative rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of dInd for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="955" column="10"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a2a8868747dc6bd639517d1027b3ec7e4" prot="public" static="no" mutable="no">
        <type>struct @32</type>
        <definition>struct @32 get_sIND</definition>
        <argsstring></argsstring>
        <name>get_sIND</name>
        <briefdescription>
<para>Similarity index. </para>
        </briefdescription>
        <detaileddescription>
<para>sInd is comprised between 0 (no correct classifications) and 1 (perfect classification).</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">sInd<sp/>=<sp/>1<sp/>-<sp/>dInd</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dInd</parametername>
</parameternamelist>
<parameterdescription>
<para>array of distance indexes for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of sInd for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="981" column="10"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a49bf9458ab109c93247b4014913251a3" prot="public" static="no" mutable="no">
        <type>struct @33</type>
        <definition>struct @33 get_DP</definition>
        <argsstring></argsstring>
        <name>get_DP</name>
        <briefdescription>
<para>Discriminant power. </para>
        </briefdescription>
        <detaileddescription>
<para>Discriminant power (DP) is a measure that summarizes sensitivity and specificity. The DP has been used mainly in feature selection over imbalanced data.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">DP<sp/>=<sp/>(sqrt(3)<sp/>/<sp/>π<sp/>)<sp/>*<sp/>(log10(TPR<sp/>/<sp/>(1<sp/>-<sp/>TPR))<sp/>+<sp/>log10(TNR<sp/>/<sp/>(1<sp/>-<sp/>TNR)))</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negative rates </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of DP for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1009" column="8"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a7600b2c3f0523e25b0b663759bd771e3" prot="public" static="no" mutable="no">
        <type>struct @34</type>
        <definition>struct @34 get_Y</definition>
        <argsstring></argsstring>
        <name>get_Y</name>
        <briefdescription>
<para>Youden index. </para>
        </briefdescription>
        <detaileddescription>
<para>Youden’s index evaluates the algorithm’s ability to avoid failure; it’s derived from sensitivity and specificity and denotes a linear correspondence balanced accuracy. As Youden’s index is a linear transformation of the mean sensitivity and specificity, its values are difficult to interpret, we retain that a higher value of Y indicates better ability to avoid failure. Youden’s index has been conventionally used to evaluate tests diagnostic, improve the efficiency of Telemedical prevention.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">Y<sp/>=<sp/>BM<sp/>=<sp/>TPR<sp/>+<sp/>TNR<sp/>-<sp/>1</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>BM</parametername>
</parameternamelist>
<parameterdescription>
<para>array of bookmaker indexes for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of Y for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1041" column="7"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a3ea0f245d5a66cf25f4d6cd78bc3b1d0" prot="public" static="no" mutable="no">
        <type>struct @35</type>
        <definition>struct @35 get_PLRI</definition>
        <argsstring></argsstring>
        <name>get_PLRI</name>
        <briefdescription>
<para>Positive likelihood ratio interpretation. </para>
        </briefdescription>
        <detaileddescription>
<para>The score follows the ranges<itemizedlist>
<listitem><para>PLR &lt; 1 Negligible</para>
</listitem><listitem><para>1 &lt; PLR &lt; 5 Poor</para>
</listitem><listitem><para>5 &lt; PLR &lt; 10 Fair</para>
</listitem><listitem><para>PLR &gt; 10 Good</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>PLR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive likelihood ratio values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of PLRI for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1066" column="10"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a94bfd28cd92bffdddb6ac8803abdf71b" prot="public" static="no" mutable="no">
        <type>struct @36</type>
        <definition>struct @36 get_NLRI</definition>
        <argsstring></argsstring>
        <name>get_NLRI</name>
        <briefdescription>
<para>Negative likelihood ratio interpretation. </para>
        </briefdescription>
        <detaileddescription>
<para>The score follows the ranges<itemizedlist>
<listitem><para>0.5 &lt; NLR &lt; 1 Negligible</para>
</listitem><listitem><para>0.2 &lt; NLR &lt; 0.5 Poor</para>
</listitem><listitem><para>0.1 &lt; NLR &lt; 0.2 Fair</para>
</listitem><listitem><para>NLR &gt; 0.1 Good</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>NLR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of negative likelihood ratio values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of NLRI for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1091" column="10"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a956d14f4c2f4ed5dfebfd9c78b9cc747" prot="public" static="no" mutable="no">
        <type>struct @37</type>
        <definition>struct @37 get_DPI</definition>
        <argsstring></argsstring>
        <name>get_DPI</name>
        <briefdescription>
<para>Discriminant power interpretation. </para>
        </briefdescription>
        <detaileddescription>
<para>The score follows the ranges<itemizedlist>
<listitem><para>DPI &lt; 1 Poor</para>
</listitem><listitem><para>1 &lt; DPI &lt; 2 Limited</para>
</listitem><listitem><para>2 &lt; DPI &lt; 3 Fair</para>
</listitem><listitem><para>DPI &gt; 3 Good</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>DP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of discriminant power values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of DPI for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1116" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a207c2c4eb2749fa8276ffaf809ed037c" prot="public" static="no" mutable="no">
        <type>struct @38</type>
        <definition>struct @38 get_AUCI</definition>
        <argsstring></argsstring>
        <name>get_AUCI</name>
        <briefdescription>
<para>AUC value interpretation. </para>
        </briefdescription>
        <detaileddescription>
<para>The score follows the ranges<itemizedlist>
<listitem><para>0.5 &lt; AUCI &gt; 0.6 Poor</para>
</listitem><listitem><para>0.6 &lt; AUCI &lt; 0.7 Fair</para>
</listitem><listitem><para>0.7 &lt; AUCI &lt; 0.8 Good</para>
</listitem><listitem><para>0.8 &lt; AUCI &lt; 0.9 Very good</para>
</listitem><listitem><para>0.9 &lt; AUCI &lt; 1.0 Excellent</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>AUC</parametername>
</parameternamelist>
<parameterdescription>
<para>array of area under the curve values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of AUCI for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1142" column="10"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a7c3337082af672dcbd207c2be415909a" prot="public" static="no" mutable="no">
        <type>struct @39</type>
        <definition>struct @39 get_GI</definition>
        <argsstring></argsstring>
        <name>get_GI</name>
        <briefdescription>
<para>Gini index. </para>
        </briefdescription>
        <detaileddescription>
<para>A chance-standardized variant of the AUC is given by Gini coefficient, taking values between 0 (no difference between the score distributions of the two classes) and 1 (complete separation between the two distributions). Gini coefficient is widespread use metric in imbalanced data learning.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">GI<sp/>=<sp/>2<sp/>*<sp/>AUC<sp/>-<sp/>1</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>AUC</parametername>
</parameternamelist>
<parameterdescription>
<para>array of area under the curve values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of Gini-index scores for each class </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1171" column="8"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a387b17726f52083d971af993d49afd93" prot="public" static="no" mutable="no">
        <type>struct @40</type>
        <definition>struct @40 get_LS</definition>
        <argsstring></argsstring>
        <name>get_LS</name>
        <briefdescription>
<para>Lift score. </para>
        </briefdescription>
        <detaileddescription>
<para>In the context of classification, lift compares model predictions to randomly generated predictions. Lift is often used in marketing research combined with gain and lift charts as a visual aid.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">LS<sp/>=<sp/>PPV<sp/>/<sp/>PRE</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>PPV</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predicted values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>PRE</parametername>
</parameternamelist>
<parameterdescription>
<para>array of prevalence scores for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of LS scores for each class </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1200" column="8"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a141fc6ec94376c53ad4a16c1b92e3e08" prot="public" static="no" mutable="no">
        <type>struct @41</type>
        <definition>struct @41 get_AM</definition>
        <argsstring></argsstring>
        <name>get_AM</name>
        <briefdescription>
<para>Automatic/Manual. </para>
        </briefdescription>
        <detaileddescription>
<para>Difference between automatic and manual classification i.e., the difference between positive outcomes and of positive samples.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">AM<sp/>=<sp/>TOP<sp/>-<sp/>P<sp/>=<sp/>(TP<sp/>+<sp/>FP)<sp/>-<sp/>(TP<sp/>+<sp/>FN)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TOP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predicted values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>array of the number of positive samples for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of AM scores for each class </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1227" column="8"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a579350c265a48baffbe7f289b387171e" prot="public" static="no" mutable="no">
        <type>struct @42</type>
        <definition>struct @42 get_OP</definition>
        <argsstring></argsstring>
        <name>get_OP</name>
        <briefdescription>
<para>Optimized precision. </para>
        </briefdescription>
        <detaileddescription>
<para>Optimized precision is a type of hybrid threshold metric and has been proposed as a discriminator for building an optimized heuristic classifier. This metric is a combination of accuracy, sensitivity and specificity metrics. The sensitivity and specificity metrics were used for stabilizing and optimizing the accuracy performance when dealing with an imbalanced class of two-class problems.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">OP<sp/>=<sp/>ACC<sp/>-<sp/>abs(TNR<sp/>-<sp/>TPR)<sp/>/<sp/>abs(TNR<sp/>+<sp/>TPR)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ACC</parametername>
</parameternamelist>
<parameterdescription>
<para>array of accuracy scores for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negative rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of OP scores for each class </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1260" column="8"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a2612ae8114244156e539072c7b7c2ab2" prot="public" static="no" mutable="no">
        <type>struct @43</type>
        <definition>struct @43 get_IBA</definition>
        <argsstring></argsstring>
        <name>get_IBA</name>
        <briefdescription>
<para>Index of balanced accuracy. </para>
        </briefdescription>
        <detaileddescription>
<para>The method combines an unbiased index of its overall accuracy and a measure about how dominant is the class with the highest individual accuracy rate.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">IBAα<sp/>=<sp/>(1<sp/>+<sp/>α<sp/>*<sp/>(TPR<sp/>-<sp/>TNR))<sp/>*<sp/>TNR<sp/>*<sp/>TPR</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negative rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of IBA scores for each class </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1287" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a4d1e9460a2d5f2ac1cfda99526cea5bd" prot="public" static="no" mutable="no">
        <type>struct @44</type>
        <definition>struct @44 get_GM</definition>
        <argsstring></argsstring>
        <name>get_GM</name>
        <briefdescription>
<para>G-mean. </para>
        </briefdescription>
        <detaileddescription>
<para>Geometric mean of specificity and sensitivity.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">GM<sp/>=<sp/>sqrt(TPR<sp/>*<sp/>TNR)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negative rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of GM scores for each class </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1313" column="8"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1afe2de8bdc7c11ea5f72841635345ba95" prot="public" static="no" mutable="no">
        <type>struct @45</type>
        <definition>struct @45 get_Q</definition>
        <argsstring></argsstring>
        <name>get_Q</name>
        <briefdescription>
<para>Yule&apos;s Q. </para>
        </briefdescription>
        <detaileddescription>
<para>In statistics, Yule&apos;s Q, also known as the coefficient of colligation, is a measure of association between two binary variables.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">OR<sp/>=<sp/>(TP<sp/>*<sp/>TN)<sp/>/<sp/>(FP<sp/>*<sp/>FN)</highlight></codeline>
<codeline><highlight class="normal">Q<sp/>=<sp/>(OR<sp/>-<sp/>1)<sp/>/<sp/>(OR<sp/>+<sp/>1)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positives for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negatives for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positives for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of Q scores for each class </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1347" column="7"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1ab0aed095be67e408618aa5545f20df07" prot="public" static="no" mutable="no">
        <type>struct @46</type>
        <definition>struct @46 get_AGM</definition>
        <argsstring></argsstring>
        <name>get_AGM</name>
        <briefdescription>
<para>Adjusted G-mean. </para>
        </briefdescription>
        <detaileddescription>
<para>An adjusted version of the geometric mean of specificity and sensitivity.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">Nn<sp/>=<sp/>N<sp/>/<sp/>POP</highlight></codeline>
<codeline><highlight class="normal">AGM<sp/>=<sp/>(GM<sp/>+<sp/>TNR<sp/>*<sp/>Nn)<sp/>/<sp/>(1<sp/>+<sp/>Nn)<sp/>if<sp/>TPR<sp/>&gt;<sp/>0<sp/>else<sp/>0</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TNR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negative rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>GM</parametername>
</parameternamelist>
<parameterdescription>
<para>array of geometric means for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>array of number of negative samples for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>POP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of total samples for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of AGM score values for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1387" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1aa462ac02b23fa3e6ca3c7dceb1abee09" prot="public" static="no" mutable="no">
        <type>struct @47</type>
        <definition>struct @47 get_MCCI</definition>
        <argsstring></argsstring>
        <name>get_MCCI</name>
        <briefdescription>
<para>Matthews correlation coefficient interpretation. </para>
        </briefdescription>
        <detaileddescription>
<para>MCC is a confusion matrix method of calculating the Pearson product-moment correlation coefficient (not to be confused with Pearson&apos;s C). Therefore, it has the same interpretation. The score follows the ranges<itemizedlist>
<listitem><para>MCCI &lt; 0.3 Negligible</para>
</listitem><listitem><para>0.3 &lt; MCCI &lt; 0.5 Weak</para>
</listitem><listitem><para>0.5 &lt; MCCI &lt; 0.7 Moderate</para>
</listitem><listitem><para>0.7 &lt; MCCI &lt; 0.9 Strong</para>
</listitem><listitem><para>0.9 &lt; MCCI &lt; 1.0 Very Strong</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>MCC</parametername>
</parameternamelist>
<parameterdescription>
<para>array of Matthews correlation coefficients for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of MCCI scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1416" column="10"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a842f9ac840fb456cac90959e50711daa" prot="public" static="no" mutable="no">
        <type>struct @48</type>
        <definition>struct @48 get_AGF</definition>
        <argsstring></argsstring>
        <name>get_AGF</name>
        <briefdescription>
<para>Adjusted F-score. </para>
        </briefdescription>
        <detaileddescription>
<para>The F-measures used only three of the four elements of the confusion matrix and hence two classifiers with different TNR values may have the same F-score. Therefore, the AGF metric is introduced to use all elements of the confusion matrix and provide more weights to samples which are correctly classified in the minority class.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">F2<sp/>=<sp/>5<sp/>*<sp/>(PPV<sp/>*<sp/>TPR)<sp/>/<sp/>((4<sp/>*<sp/>PPV)<sp/>+<sp/>TPR)</highlight></codeline>
<codeline><highlight class="normal">InvF0.5<sp/>=<sp/>(1<sp/>+<sp/>0.5**2)<sp/>*<sp/>(NPV<sp/>*<sp/>TNR)<sp/>/<sp/>((0.5**2<sp/>*<sp/>NPV)<sp/>+<sp/>TNR)</highlight></codeline>
<codeline><highlight class="normal">AGF<sp/>=<sp/>sqrt(F2<sp/>*<sp/>invF0.5)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false positives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of false negative </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TN</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true negatives </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of AGF scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1457" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a52758992ba041cfa0b006caab2bb2fda" prot="public" static="no" mutable="no">
        <type>struct @49</type>
        <definition>struct @49 get_OC</definition>
        <argsstring></argsstring>
        <name>get_OC</name>
        <briefdescription>
<para>Overlap coefficient. </para>
        </briefdescription>
        <detaileddescription>
<para>The overlap coefficient, or Szymkiewicz–Simpson coefficient, is a similarity measure that measures the overlap between two finite sets. It is defined as the size of the intersection divided by the smaller of the size of the two sets.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">OC<sp/>=<sp/>TP<sp/>/<sp/>min(TOP,<sp/>P)<sp/>=<sp/>max(PPV,<sp/>TPR)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TOP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predicted values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>array of the number of positive samples for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of OC values for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1491" column="8"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a4b0d8881921f0084de34f7f8613ece90" prot="public" static="no" mutable="no">
        <type>struct @50</type>
        <definition>struct @50 get_OOC</definition>
        <argsstring></argsstring>
        <name>get_OOC</name>
        <briefdescription>
<para>Otsuka-Ochiai coefficient. </para>
        </briefdescription>
        <detaileddescription>
<para>In biology, there is a similarity index, known as the Otsuka-Ochiai coefficient named after Yanosuke Otsuka and Akira Ochiai, also known as the Ochiai-Barkman or Ochiai coefficient. If sets are represented as bit vectors, the Otsuka-Ochiai coefficient can be seen to be the same as the cosine similarity.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">OOC<sp/>=<sp/>TP<sp/>/<sp/>sqrt(TOP<sp/>*<sp/>P)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TOP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predicted values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>array of the number of positive samples for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of OOC values for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1526" column="9"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a09d309212b0d0d11c991f5051a0ef5c8" prot="public" static="no" mutable="no">
        <type>struct @51</type>
        <definition>struct @51 get_AUPR</definition>
        <argsstring></argsstring>
        <name>get_AUPR</name>
        <briefdescription>
<para>Area under the PR curve. </para>
        </briefdescription>
        <detaileddescription>
<para>A PR curve is plotting precision against recall. The precision recall area under curve (AUPR) is just the area under the PR curve. The higher it is, the better the model is.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">AUPR<sp/>=<sp/>(TPR<sp/>+<sp/>PPV)<sp/>/<sp/>2</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>PPV</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predicted values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TPR</parametername>
</parameternamelist>
<parameterdescription>
<para>array of true positive rates for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of AUPR values for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1555" column="10"/>
      </memberdef>
      <memberdef kind="variable" id="class__stats_8h_1a82d6e3abbb345428912773e5dbcf8816" prot="public" static="no" mutable="no">
        <type>struct @52</type>
        <definition>struct @52 get_BCD</definition>
        <argsstring></argsstring>
        <name>get_BCD</name>
        <briefdescription>
<para>Bray-Curtis dissimilarity. </para>
        </briefdescription>
        <detaileddescription>
<para>In ecology and biology, the Bray–Curtis dissimilarity, named after J. Roger Bray and John T. Curtis, is a statistic used to quantify the compositional dissimilarity between two different sites, based on counts at each site.</para>
<para><programlisting filename=".python"><codeline><highlight class="normal">BCD<sp/>=<sp/>abs(AM)<sp/>/<sp/>sum(TOP<sp/>+<sp/>P)</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>TOP</parametername>
</parameternamelist>
<parameterdescription>
<para>array of positive predicted values for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>array of the number of positive samples for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>AM</parametername>
</parameternamelist>
<parameterdescription>
<para>array of Automatic/Manual differences for each class. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Nclass</parametername>
</parameternamelist>
<parameterdescription>
<para>size of classes array (aka number of classes)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The array of BCD scores for each class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/nico/Code/scorer/include/class_stats.h" line="1585" column="9"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#ifndef<sp/>__class_stats_h__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>__class_stats_h__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="common__stats_8h" kindref="compound">common_stats.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>TOP(Test<sp/>outcome<sp/>positive)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal">{</highlight></codeline>
<codeline lineno="22"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="23"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>TOP<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="25"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TP,<sp/>TP<sp/>+<sp/>Nclass,<sp/>FP,<sp/>TOP.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tp,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>fp){return<sp/>tp<sp/>+<sp/>fp;});</highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>TOP;</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="28"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a4f571c2867f0b5a5071d4baf8a3537b7" kindref="member">get_TOP</ref>;</highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>TON(Test<sp/>outcome<sp/>negative)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="normal">{</highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>TON<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TN,<sp/>TN<sp/>+<sp/>Nclass,<sp/>FN,<sp/>TON.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tn,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>fn){return<sp/>tn<sp/>+<sp/>fn;});</highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>TON;</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="52"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1ae2a524794da550c05f8e4b8b6c76ab71" kindref="member">get_TON</ref>;</highlight></codeline>
<codeline lineno="53"><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>TPR(Sensitivity<sp/>/<sp/>recall<sp/>/<sp/>hit<sp/>rate<sp/>/<sp/>true<sp/>positive<sp/>rate)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="73"><highlight class="normal">{</highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>TPR<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TP,<sp/>TP<sp/>+<sp/>Nclass,<sp/>FN,<sp/>TPR.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>i1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>i2){return<sp/>i1<sp/>/<sp/>(i1<sp/>+<sp/>i2);});</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>TPR;</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="80"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a3804210e6ecc00435597d154be2ce4e2" kindref="member">get_TPR</ref>;</highlight></codeline>
<codeline lineno="81"><highlight class="normal"></highlight></codeline>
<codeline lineno="100"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>TNR(Specificity<sp/>or<sp/>true<sp/>negative<sp/>rate)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="101"><highlight class="normal">{</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>TNR<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TN,<sp/>TN<sp/>+<sp/>Nclass,<sp/>FP,<sp/>TNR.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>i1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>i2){return<sp/>i1<sp/>/<sp/>(i1<sp/>+<sp/>i2);});</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>TNR;</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="108"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a834276bf2047f892965a07ddab5465f4" kindref="member">get_TNR</ref>;</highlight></codeline>
<codeline lineno="109"><highlight class="normal"></highlight></codeline>
<codeline lineno="126"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>PPV(Precision<sp/>or<sp/>positive<sp/>predictive<sp/>value)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="127"><highlight class="normal">{</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>PPV<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TP,<sp/>TP<sp/>+<sp/>Nclass,<sp/>FP,<sp/>PPV.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>i1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>i2){return<sp/>i1<sp/>/<sp/>(i1<sp/>+<sp/>i2);});</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PPV;</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="134"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1ae0aa1ab53c1315a74412b550b5bed0f0" kindref="member">get_PPV</ref>;</highlight></codeline>
<codeline lineno="135"><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>NPV(Negative<sp/>predictive<sp/>value)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="153"><highlight class="normal">{</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>NPV<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TN,<sp/>TN<sp/>+<sp/>Nclass,<sp/>FN,<sp/>NPV.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>i1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>i2){return<sp/>i1<sp/>/<sp/>(i1<sp/>+<sp/>i2);});</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NPV;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="160"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1ae2a82ae30d655bd5724e7497947cc478" kindref="member">get_NPV</ref>;</highlight></codeline>
<codeline lineno="161"><highlight class="normal"></highlight></codeline>
<codeline lineno="178"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>FNR(Miss<sp/>rate<sp/>or<sp/>false<sp/>negative<sp/>rate)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="179"><highlight class="normal">{</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>FNR<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TPR,<sp/>TPR<sp/>+<sp/>Nclass,<sp/>FNR.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>item){return<sp/>1.f<sp/>-<sp/>item;});</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FNR;</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="186"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a088799efa94fcd27f75777d228d89f58" kindref="member">get_FNR</ref>;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>FPR(Fall-out<sp/>or<sp/>false<sp/>positive<sp/>rate)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal">{</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>FPR<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TNR,<sp/>TNR<sp/>+<sp/>Nclass,<sp/>FPR.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>item){return<sp/>1.f<sp/>-<sp/>item;});</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FPR;</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="214"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1aca584c48b01afddfc7e4a5932a221f1f" kindref="member">get_FPR</ref>;</highlight></codeline>
<codeline lineno="215"><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>FDR(False<sp/>discovery<sp/>rate)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="235"><highlight class="normal">{</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>PPV,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>FDR<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(PPV,<sp/>PPV<sp/>+<sp/>Nclass,<sp/>FDR.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>item){return<sp/>1.f<sp/>-<sp/>item;});</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FDR;</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="242"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1ad8dbeb51e4bd0879ebe897b098892309" kindref="member">get_FDR</ref>;</highlight></codeline>
<codeline lineno="243"><highlight class="normal"></highlight></codeline>
<codeline lineno="261"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>FOR(False<sp/>omission<sp/>rate)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="262"><highlight class="normal">{</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>NPV,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>FOR<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(NPV,<sp/>NPV<sp/>+<sp/>Nclass,<sp/>FOR.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>item){return<sp/>1.f<sp/>-<sp/>item;});</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FOR;</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="269"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1ad66d23a797168b8d1ae7c9be7c2aeb85" kindref="member">get_FOR</ref>;</highlight></codeline>
<codeline lineno="270"><highlight class="normal"></highlight></codeline>
<codeline lineno="289"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>ACC(Accuracy)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal">{</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>ACC<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ACC[i]<sp/>=<sp/>(<sp/>TP[i]<sp/>+<sp/>TN[i]<sp/>)<sp/>/<sp/>(TP[i]<sp/>+<sp/>TN[i]<sp/>+<sp/>FN[i]<sp/>+<sp/>FP[i]);</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ACC;</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="298"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1aca1effd3fe98d13cfd3840068136dcc7" kindref="member">get_ACC</ref>;</highlight></codeline>
<codeline lineno="299"><highlight class="normal"></highlight></codeline>
<codeline lineno="323"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>F1(F1<sp/>score<sp/>-<sp/>harmonic<sp/>mean<sp/>of<sp/>precision<sp/>and<sp/>sensitivity)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="324"><highlight class="normal">{</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>F1_SCORE<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>F1_SCORE[i]<sp/>=<sp/>(2.f<sp/>*<sp/>TP[i])<sp/>/<sp/>(2.f<sp/>*<sp/>TP[i]<sp/>+<sp/>FP[i]<sp/>+<sp/>FN[i]);</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>F1_SCORE;</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="332"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1ac498b4ad6fc24bbe00ad0a3ece250085" kindref="member">get_F1_SCORE</ref>;</highlight></codeline>
<codeline lineno="333"><highlight class="normal"></highlight></codeline>
<codeline lineno="357"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>F0.5(F0.5<sp/>score)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="358"><highlight class="normal">{</highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>F05_SCORE<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>F05_SCORE[i]<sp/>=<sp/>(1.25f<sp/>*<sp/>TP[i])<sp/>/<sp/>(1.25f<sp/>*<sp/>TP[i]<sp/>+<sp/>FP[i]<sp/>+<sp/>.25f<sp/>*<sp/>FN[i]);</highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>F05_SCORE;</highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="366"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a09f8b8bdbc942775a7266d8f859e3436" kindref="member">get_F05_SCORE</ref>;</highlight></codeline>
<codeline lineno="367"><highlight class="normal"></highlight></codeline>
<codeline lineno="391"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>F2(F2<sp/>score)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="392"><highlight class="normal">{</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>F2_SCORE<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>F2_SCORE[i]<sp/>=<sp/>(5.f<sp/>*<sp/>TP[i])<sp/>/<sp/>(5.f<sp/>*<sp/>TP[i]<sp/>+<sp/>FP[i]<sp/>+<sp/>4.f<sp/>*<sp/>FN[i]);</highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>F2_SCORE;</highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="400"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a9dc5ed5df7ab3ca27584cceec3fdf11a" kindref="member">get_F2_SCORE</ref>;</highlight></codeline>
<codeline lineno="401"><highlight class="normal"></highlight></codeline>
<codeline lineno="427"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>MCC(Matthews<sp/>correlation<sp/>coefficient)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="428"><highlight class="normal">{</highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>MCC<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>MCC[i]<sp/>=<sp/>(TP[i]<sp/>*<sp/>TN[i]<sp/>-<sp/>FP[i]<sp/>*<sp/>FN[i])<sp/>/<sp/>(std<sp/>::<sp/>sqrt(<sp/>(TP[i]<sp/>+<sp/>FP[i])<sp/>*<sp/>(TP[i]<sp/>+<sp/>FN[i])<sp/>*<sp/>(TN[i]<sp/>+<sp/>FP[i])<sp/>*<sp/>(TN[i]<sp/>+<sp/>FN[i])<sp/>));</highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MCC;</highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="436"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1aa9c90387d1ddb6f26781c723b8a9465e" kindref="member">get_MCC</ref>;</highlight></codeline>
<codeline lineno="437"><highlight class="normal"></highlight></codeline>
<codeline lineno="456"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>BM(Informedness<sp/>or<sp/>bookmaker<sp/>informedness)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="457"><highlight class="normal">{</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>BM<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TPR,<sp/>TPR<sp/>+<sp/>Nclass,<sp/>TNR,<sp/>BM.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tp,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tn){return<sp/>tp<sp/>+<sp/>tn<sp/>-<sp/>1.f;});</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>BM;</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="464"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1abe903bf400b3d634f70419a2168499c1" kindref="member">get_BM</ref>;</highlight></codeline>
<codeline lineno="465"><highlight class="normal"></highlight></codeline>
<codeline lineno="483"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>MK(Markedness)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="484"><highlight class="normal">{</highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>PPV,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>NPV,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="487"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>MK<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="488"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(PPV,<sp/>PPV<sp/>+<sp/>Nclass,<sp/>NPV,<sp/>MK.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tp,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tn){return<sp/>tp<sp/>+<sp/>tn<sp/>-<sp/>1.f;});</highlight></codeline>
<codeline lineno="489"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MK;</highlight></codeline>
<codeline lineno="490"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="491"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a25fc19b5601dba9de79540d1639d0aea" kindref="member">get_MK</ref>;</highlight></codeline>
<codeline lineno="492"><highlight class="normal"></highlight></codeline>
<codeline lineno="513"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>ICSI(Individual<sp/>classification<sp/>success<sp/>index)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="514"><highlight class="normal">{</highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>PPV,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="516"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="517"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>ICSI<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(PPV,<sp/>PPV<sp/>+<sp/>Nclass,<sp/>TPR,<sp/>ICSI.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tp,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tn){return<sp/>tp<sp/>+<sp/>tn<sp/>-<sp/>1.f;});</highlight></codeline>
<codeline lineno="519"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ICSI;</highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="521"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a437422d689c8d462703adcf98784eb0b" kindref="member">get_ICSI</ref>;</highlight></codeline>
<codeline lineno="522"><highlight class="normal"></highlight></codeline>
<codeline lineno="542"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>PLR(Positive<sp/>likelihood<sp/>ratio)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="543"><highlight class="normal">{</highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>PLR<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TPR,<sp/>TPR<sp/>+<sp/>Nclass,<sp/>FPR,<sp/>PLR.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tp,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tn){return<sp/>tp<sp/>/<sp/>tn;});</highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PLR;</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="550"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a0d9856733d36e2d842f94df49d38faf2" kindref="member">get_PLR</ref>;</highlight></codeline>
<codeline lineno="551"><highlight class="normal"></highlight></codeline>
<codeline lineno="571"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>NLR(Negative<sp/>likelihood<sp/>ratio)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="572"><highlight class="normal">{</highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="574"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>NLR<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(FNR,<sp/>FNR<sp/>+<sp/>Nclass,<sp/>TNR,<sp/>NLR.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tp,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tn){return<sp/>tp<sp/>/<sp/>tn;});</highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NLR;</highlight></codeline>
<codeline lineno="578"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="579"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1aad5d70ce26c5acd55bd3e02605136d9c" kindref="member">get_NLR</ref>;</highlight></codeline>
<codeline lineno="580"><highlight class="normal"></highlight></codeline>
<codeline lineno="599"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>DOR(Diagnostic<sp/>odds<sp/>ratio)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="600"><highlight class="normal">{</highlight></codeline>
<codeline lineno="601"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>PLR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>NLR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="602"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="603"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>DOR<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="604"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(PLR,<sp/>PLR<sp/>+<sp/>Nclass,<sp/>NLR,<sp/>DOR.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tp,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tn){return<sp/>tp<sp/>/<sp/>tn;});</highlight></codeline>
<codeline lineno="605"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>DOR;</highlight></codeline>
<codeline lineno="606"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="607"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a4d3758db8977cff40410599faa8f756c" kindref="member">get_DOR</ref>;</highlight></codeline>
<codeline lineno="608"><highlight class="normal"></highlight></codeline>
<codeline lineno="626"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>PRE(Prevalence)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="627"><highlight class="normal">{</highlight></codeline>
<codeline lineno="628"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>P,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>POP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="629"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="630"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>PRE<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="631"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(P,<sp/>P<sp/>+<sp/>Nclass,<sp/>POP,<sp/>PRE.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>p,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>pop){return<sp/>p<sp/>/<sp/>pop;});</highlight></codeline>
<codeline lineno="632"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PRE;</highlight></codeline>
<codeline lineno="633"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="634"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a406539d7361740226dd168817d6a226d" kindref="member">get_PRE</ref>;</highlight></codeline>
<codeline lineno="635"><highlight class="normal"></highlight></codeline>
<codeline lineno="652"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>G(G-measure<sp/>geometric<sp/>mean<sp/>of<sp/>precision<sp/>and<sp/>sensitivity)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="653"><highlight class="normal">{</highlight></codeline>
<codeline lineno="654"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>PPV,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="655"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="656"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>G<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="657"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(PPV,<sp/>PPV<sp/>+<sp/>Nclass,<sp/>TPR,<sp/>G.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>i1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>i2){return<sp/>std<sp/>::<sp/>sqrt(i1<sp/>*<sp/>i2);});</highlight></codeline>
<codeline lineno="658"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>G;</highlight></codeline>
<codeline lineno="659"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="660"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a7f628f8c8883b51763d734ffe8cf6d23" kindref="member">get_G</ref>;</highlight></codeline>
<codeline lineno="661"><highlight class="normal"></highlight></codeline>
<codeline lineno="679"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>RACC(Random<sp/>accuracy)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="680"><highlight class="normal">{</highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TOP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>P,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>POP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="682"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="683"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>RACC<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>RACC[i]<sp/>=<sp/>(TOP[i]<sp/>*<sp/>P[i])<sp/>/<sp/>(POP[i]<sp/>*<sp/>POP[i]);</highlight></codeline>
<codeline lineno="686"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>RACC;</highlight></codeline>
<codeline lineno="687"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="688"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a764a34712459bbc30493529dcb0dd851" kindref="member">get_RACC</ref>;</highlight></codeline>
<codeline lineno="689"><highlight class="normal"></highlight></codeline>
<codeline lineno="704"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>ERR(Error<sp/>rate)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="705"><highlight class="normal">{</highlight></codeline>
<codeline lineno="706"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>ACC,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="707"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>ERR_ACC<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(ACC,<sp/>ACC<sp/>+<sp/>Nclass,<sp/>ERR_ACC.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>acc){return<sp/>1.f<sp/>-<sp/>acc;});</highlight></codeline>
<codeline lineno="710"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ERR_ACC;</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="712"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1af5aa85580b48b241cc4454b2f055a569" kindref="member">get_ERR_ACC</ref>;</highlight></codeline>
<codeline lineno="713"><highlight class="normal"></highlight></codeline>
<codeline lineno="731"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>RACCU(Random<sp/>accuracy<sp/>unbiased)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="732"><highlight class="normal">{</highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TOP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>P,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>POP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>RACCU<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="736"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>RACCU[i]<sp/>=<sp/>(<sp/>(TOP[i]<sp/>+<sp/>P[i])<sp/>*<sp/>(TOP[i]<sp/>+<sp/>P[i])<sp/>)<sp/>/<sp/>(POP[i]<sp/>*<sp/>POP[i]<sp/>*<sp/>4.f);</highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>RACCU;</highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="740"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a491666a86299e747c43a6a9f25b74f70" kindref="member">get_RACCU</ref>;</highlight></codeline>
<codeline lineno="741"><highlight class="normal"></highlight></codeline>
<codeline lineno="761"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>J(Jaccard<sp/>index)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="762"><highlight class="normal">{</highlight></codeline>
<codeline lineno="763"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TOP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>P,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="764"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="765"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>jaccard_index<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="766"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>jaccard_index[i]<sp/>=<sp/>TP[i]<sp/>/<sp/>(TOP[i]<sp/>+<sp/>P[i]<sp/>-<sp/>TP[i]);</highlight></codeline>
<codeline lineno="768"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>jaccard_index;</highlight></codeline>
<codeline lineno="769"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="770"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a7aea102ac6ce28d17c10ffbdc43bb0fa" kindref="member">get_jaccard_index</ref>;</highlight></codeline>
<codeline lineno="771"><highlight class="normal"></highlight></codeline>
<codeline lineno="790"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>IS(Information<sp/>score)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="791"><highlight class="normal">{</highlight></codeline>
<codeline lineno="792"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>POP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="793"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="794"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>IS<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="795"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>IS[i]<sp/>=<sp/>-std<sp/>::<sp/>log2((TP[i]<sp/>+<sp/>FN[i])<sp/>/<sp/>POP[i])<sp/>+<sp/>(std<sp/>::<sp/>log2(TP[i]<sp/>/<sp/>(TP[i]<sp/>+<sp/>FP[i])));</highlight></codeline>
<codeline lineno="797"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>IS;</highlight></codeline>
<codeline lineno="798"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="799"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a86f8345d5a0ecda157ccd993f3833c46" kindref="member">get_IS</ref>;</highlight></codeline>
<codeline lineno="800"><highlight class="normal"></highlight></codeline>
<codeline lineno="820"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>CEN(Confusion<sp/>entropy)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="821"><highlight class="normal">{</highlight></codeline>
<codeline lineno="822"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>confusion_matrix,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="823"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="824"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>CEN<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="825"><highlight class="normal"></highlight></codeline>
<codeline lineno="826"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="827"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CEN[i]<sp/>=<sp/>0.f;</highlight></codeline>
<codeline lineno="829"><highlight class="normal"></highlight></codeline>
<codeline lineno="830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>Nclass;<sp/>++j)</highlight></codeline>
<codeline lineno="831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>!=<sp/>i)</highlight></codeline>
<codeline lineno="833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>CEN_misclassification_calc<sp/>=<sp/>0.f;</highlight></codeline>
<codeline lineno="835"><highlight class="normal"></highlight></codeline>
<codeline lineno="836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>Nclass;<sp/>++k)</highlight></codeline>
<codeline lineno="837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CEN_misclassification_calc<sp/>+=<sp/>confusion_matrix[i<sp/>*<sp/>Nclass<sp/>+<sp/>k]<sp/>+<sp/>confusion_matrix[<sp/>k<sp/>*<sp/>Nclass<sp/>+<sp/>i];</highlight></codeline>
<codeline lineno="838"><highlight class="normal"></highlight></codeline>
<codeline lineno="839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>P_j_k<sp/>=<sp/>confusion_matrix[i<sp/>*<sp/>Nclass<sp/>+<sp/>j]<sp/>/<sp/>CEN_misclassification_calc;</highlight></codeline>
<codeline lineno="840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>P_k_j<sp/>=<sp/>confusion_matrix[j<sp/>*<sp/>Nclass<sp/>+<sp/>i]<sp/>/<sp/>CEN_misclassification_calc;</highlight></codeline>
<codeline lineno="841"><highlight class="normal"></highlight></codeline>
<codeline lineno="842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CEN[i]<sp/>+=<sp/>P_j_k<sp/>!=<sp/>0.f<sp/>?<sp/>P_j_k<sp/>*<sp/>(std<sp/>::<sp/>log(P_j_k)<sp/>/<sp/>std<sp/>::<sp/>log(2<sp/>*<sp/>(Nclass<sp/>-<sp/>1)))<sp/>:<sp/>0.f;</highlight></codeline>
<codeline lineno="843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CEN[i]<sp/>+=<sp/>P_k_j<sp/>!=<sp/>0.f<sp/>?<sp/>P_k_j<sp/>*<sp/>(std<sp/>::<sp/>log(P_k_j)<sp/>/<sp/>std<sp/>::<sp/>log(2<sp/>*<sp/>(Nclass<sp/>-<sp/>1)))<sp/>:<sp/>0.f;</highlight></codeline>
<codeline lineno="844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="846"><highlight class="normal"></highlight></codeline>
<codeline lineno="847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>CEN[i]<sp/>=<sp/>-CEN[i];</highlight></codeline>
<codeline lineno="848"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="849"><highlight class="normal"></highlight></codeline>
<codeline lineno="850"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>CEN;</highlight></codeline>
<codeline lineno="851"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="852"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a639fe3a8c1c48a2d97b9a8b023275faa" kindref="member">get_CEN</ref>;</highlight></codeline>
<codeline lineno="853"><highlight class="normal"></highlight></codeline>
<codeline lineno="864"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>MCEN(Modified<sp/>confusion<sp/>entropy)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="865"><highlight class="normal">{</highlight></codeline>
<codeline lineno="866"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>confusion_matrix,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="867"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="868"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>MCEN<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="869"><highlight class="normal"></highlight></codeline>
<codeline lineno="870"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="871"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>MCEN[i]<sp/>=<sp/>0.f;</highlight></codeline>
<codeline lineno="873"><highlight class="normal"></highlight></codeline>
<codeline lineno="874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>Nclass;<sp/>++j)</highlight></codeline>
<codeline lineno="875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(j<sp/>!=<sp/>i)</highlight></codeline>
<codeline lineno="877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>CEN_misclassification_calc<sp/>=<sp/>0.f;</highlight></codeline>
<codeline lineno="879"><highlight class="normal"></highlight></codeline>
<codeline lineno="880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>Nclass;<sp/>++k)</highlight></codeline>
<codeline lineno="881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CEN_misclassification_calc<sp/>+=<sp/>confusion_matrix[i<sp/>*<sp/>Nclass<sp/>+<sp/>k]<sp/>+<sp/>confusion_matrix[<sp/>k<sp/>*<sp/>Nclass<sp/>+<sp/>i];</highlight></codeline>
<codeline lineno="882"><highlight class="normal"></highlight></codeline>
<codeline lineno="883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CEN_misclassification_calc<sp/>-=<sp/>confusion_matrix[i<sp/>*<sp/>Nclass<sp/>+<sp/>i];</highlight></codeline>
<codeline lineno="884"><highlight class="normal"></highlight></codeline>
<codeline lineno="885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>P_j_k<sp/>=<sp/>confusion_matrix[i<sp/>*<sp/>Nclass<sp/>+<sp/>j]<sp/>/<sp/>CEN_misclassification_calc;</highlight></codeline>
<codeline lineno="886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>P_k_j<sp/>=<sp/>confusion_matrix[j<sp/>*<sp/>Nclass<sp/>+<sp/>i]<sp/>/<sp/>CEN_misclassification_calc;</highlight></codeline>
<codeline lineno="887"><highlight class="normal"></highlight></codeline>
<codeline lineno="888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MCEN[i]<sp/>+=<sp/>P_j_k<sp/>!=<sp/>0.f<sp/>?<sp/>P_j_k<sp/>*<sp/>(std<sp/>::<sp/>log(P_j_k)<sp/>/<sp/>std<sp/>::<sp/>log(2<sp/>*<sp/>(Nclass<sp/>-<sp/>1)))<sp/>:<sp/>0.f;</highlight></codeline>
<codeline lineno="889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MCEN[i]<sp/>+=<sp/>P_k_j<sp/>!=<sp/>0.f<sp/>?<sp/>P_k_j<sp/>*<sp/>(std<sp/>::<sp/>log(P_k_j)<sp/>/<sp/>std<sp/>::<sp/>log(2<sp/>*<sp/>(Nclass<sp/>-<sp/>1)))<sp/>:<sp/>0.f;</highlight></codeline>
<codeline lineno="890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="892"><highlight class="normal"></highlight></codeline>
<codeline lineno="893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>MCEN[i]<sp/>=<sp/>-MCEN[i];</highlight></codeline>
<codeline lineno="894"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="895"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MCEN;</highlight></codeline>
<codeline lineno="896"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="897"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a967a674734a10321891a32db5d1f4aec" kindref="member">get_MCEN</ref>;</highlight></codeline>
<codeline lineno="898"><highlight class="normal"></highlight></codeline>
<codeline lineno="919"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>AUC(Area<sp/>Under<sp/>the<sp/>ROC<sp/>curve)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="920"><highlight class="normal">{</highlight></codeline>
<codeline lineno="921"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="922"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="923"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>AUC<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="924"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TNR,<sp/>TNR<sp/>+<sp/>Nclass,<sp/>TPR,<sp/>AUC.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tnr,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tpr){return<sp/>(tnr<sp/>+<sp/>tpr)<sp/>*<sp/>.5f;});</highlight></codeline>
<codeline lineno="925"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AUC;</highlight></codeline>
<codeline lineno="926"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="927"><highlight class="normal"></highlight></codeline>
<codeline lineno="928"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a85e0fa3f6dc1addfb5595f8c202597cc" kindref="member">get_AUC</ref>;</highlight></codeline>
<codeline lineno="929"><highlight class="normal"></highlight></codeline>
<codeline lineno="946"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>dInd(Distance<sp/>index)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="947"><highlight class="normal">{</highlight></codeline>
<codeline lineno="948"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="949"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="950"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>dIND<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="951"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TNR,<sp/>TNR<sp/>+<sp/>Nclass,<sp/>TPR,<sp/>dIND.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tnr,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tpr){return<sp/>std<sp/>::<sp/>sqrt(<sp/>(1.f<sp/>-<sp/>tnr)<sp/>*<sp/>(1.f<sp/>-<sp/>tnr)<sp/>+<sp/>(1.f<sp/>-<sp/>tpr)<sp/>*<sp/>(1.f<sp/>-<sp/>tpr)<sp/>);});</highlight></codeline>
<codeline lineno="952"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>dIND;</highlight></codeline>
<codeline lineno="953"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="954"><highlight class="normal"></highlight></codeline>
<codeline lineno="955"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1ab216c2990c8cbd60104ae5fbf6c64319" kindref="member">get_dIND</ref>;</highlight></codeline>
<codeline lineno="956"><highlight class="normal"></highlight></codeline>
<codeline lineno="972"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>sInd(Similarity<sp/>index)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="973"><highlight class="normal">{</highlight></codeline>
<codeline lineno="974"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>dIND,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="975"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="976"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>sIND<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="977"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(dIND,<sp/>dIND<sp/>+<sp/>Nclass,<sp/>sIND.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>dind){return<sp/>1.f<sp/>-<sp/>(dind<sp/>/<sp/>std<sp/>::<sp/>sqrt(2));});</highlight></codeline>
<codeline lineno="978"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>sIND;</highlight></codeline>
<codeline lineno="979"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="980"><highlight class="normal"></highlight></codeline>
<codeline lineno="981"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a2a8868747dc6bd639517d1027b3ec7e4" kindref="member">get_sIND</ref>;</highlight></codeline>
<codeline lineno="982"><highlight class="normal"></highlight></codeline>
<codeline lineno="1000"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>DP(Discriminant<sp/>power)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1001"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1002"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1003"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1004"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>DP<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1005"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TPR,<sp/>TPR<sp/>+<sp/>Nclass,<sp/>TNR,<sp/>DP.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tpr,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tnr){return<sp/>std<sp/>::<sp/>sqrt(3)<sp/>/<sp/>3.14f<sp/>*<sp/>(std<sp/>::<sp/>log10(tpr<sp/>/<sp/>(1.f<sp/>-<sp/>tpr))<sp/>+<sp/>std<sp/>::<sp/>log10(tnr<sp/>/<sp/>(1.f<sp/>-<sp/>tnr)));});</highlight></codeline>
<codeline lineno="1006"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>DP;</highlight></codeline>
<codeline lineno="1007"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1008"><highlight class="normal"></highlight></codeline>
<codeline lineno="1009"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a49bf9458ab109c93247b4014913251a3" kindref="member">get_DP</ref>;</highlight></codeline>
<codeline lineno="1010"><highlight class="normal"></highlight></codeline>
<codeline lineno="1032"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>Y(Youden<sp/>index)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1033"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1034"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>BM,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1035"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1036"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>Y<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1037"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>copy_n(BM,<sp/>Nclass,<sp/>Y.get());</highlight></codeline>
<codeline lineno="1038"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Y;</highlight></codeline>
<codeline lineno="1039"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1040"><highlight class="normal"></highlight></codeline>
<codeline lineno="1041"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a7600b2c3f0523e25b0b663759bd771e3" kindref="member">get_Y</ref>;</highlight></codeline>
<codeline lineno="1042"><highlight class="normal"></highlight></codeline>
<codeline lineno="1057"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>PLRI(Positive<sp/>likelihood<sp/>ratio<sp/>interpretation)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1058"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1059"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>PLR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1060"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1061"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>PLRI<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1062"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(PLR,<sp/>PLR<sp/>+<sp/>Nclass,<sp/>PLRI.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>plr){return<sp/>std<sp/>::<sp/>isnan(plr)<sp/>||<sp/>std<sp/>::<sp/>isinf(plr)<sp/>?<sp/>-1.f<sp/>:<sp/>plr<sp/>&lt;<sp/>1.f<sp/>?<sp/>0.f<sp/>:<sp/>plr<sp/>&gt;=<sp/>1.f<sp/>&amp;&amp;<sp/>plr<sp/>&lt;<sp/>5.f<sp/>?<sp/>1.f<sp/>:<sp/>plr<sp/>&gt;=<sp/>5.f<sp/>&amp;&amp;<sp/>plr<sp/>&lt;<sp/>10.f<sp/>?<sp/>2.f<sp/>:<sp/>3.f;});</highlight></codeline>
<codeline lineno="1063"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>PLRI;</highlight></codeline>
<codeline lineno="1064"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1065"><highlight class="normal"></highlight></codeline>
<codeline lineno="1066"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a3ea0f245d5a66cf25f4d6cd78bc3b1d0" kindref="member">get_PLRI</ref>;</highlight></codeline>
<codeline lineno="1067"><highlight class="normal"></highlight></codeline>
<codeline lineno="1082"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>NLRI(Negative<sp/>likelihood<sp/>ratio<sp/>interpretation)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1083"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1084"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>NLR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1085"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1086"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>NLRI<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1087"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(NLR,<sp/>NLR<sp/>+<sp/>Nclass,<sp/>NLRI.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>nlr){return<sp/>std<sp/>::<sp/>isnan(nlr)<sp/>||<sp/>std<sp/>::<sp/>isinf(nlr)<sp/>?<sp/>-1.f<sp/>:<sp/>nlr<sp/>&lt;<sp/>.1f<sp/>?<sp/>0.f<sp/>:<sp/>nlr<sp/>&gt;=<sp/>.1f<sp/>&amp;&amp;<sp/>nlr<sp/>&lt;<sp/>.2f<sp/>?<sp/>1.f<sp/>:<sp/>nlr<sp/>&gt;=<sp/>.2f<sp/>&amp;&amp;<sp/>nlr<sp/>&lt;<sp/>.5f<sp/>?<sp/>2.f<sp/>:<sp/>3.f;});</highlight></codeline>
<codeline lineno="1088"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NLRI;</highlight></codeline>
<codeline lineno="1089"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1090"><highlight class="normal"></highlight></codeline>
<codeline lineno="1091"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a94bfd28cd92bffdddb6ac8803abdf71b" kindref="member">get_NLRI</ref>;</highlight></codeline>
<codeline lineno="1092"><highlight class="normal"></highlight></codeline>
<codeline lineno="1107"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>DPI(Discriminant<sp/>power<sp/>interpretation)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1108"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1109"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>DP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1110"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1111"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>DPI<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1112"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(DP,<sp/>DP<sp/>+<sp/>Nclass,<sp/>DPI.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>dp){return<sp/>std<sp/>::<sp/>isnan(dp)<sp/>||<sp/>std<sp/>::<sp/>isinf(dp)<sp/>?<sp/>-1.f<sp/>:<sp/>dp<sp/>&lt;<sp/>1.f<sp/>?<sp/>0.f<sp/>:<sp/>dp<sp/>&gt;=<sp/>1.f<sp/>&amp;&amp;<sp/>dp<sp/>&lt;<sp/>2.f<sp/>?<sp/>1.f<sp/>:<sp/>dp<sp/>&gt;=<sp/>2.f<sp/>&amp;&amp;<sp/>dp<sp/>&lt;<sp/>3.f<sp/>?<sp/>2.f<sp/>:<sp/>3.f;});</highlight></codeline>
<codeline lineno="1113"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>DPI;</highlight></codeline>
<codeline lineno="1114"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1115"><highlight class="normal"></highlight></codeline>
<codeline lineno="1116"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a956d14f4c2f4ed5dfebfd9c78b9cc747" kindref="member">get_DPI</ref>;</highlight></codeline>
<codeline lineno="1117"><highlight class="normal"></highlight></codeline>
<codeline lineno="1133"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>AUCI(AUC<sp/>value<sp/>interpretation)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1134"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1135"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>AUC,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1136"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1137"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>AUCI<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1138"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(AUC,<sp/>AUC<sp/>+<sp/>Nclass,<sp/>AUCI.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>auc){return<sp/>std<sp/>::<sp/>isnan(auc)<sp/>||<sp/>std<sp/>::<sp/>isinf(auc)<sp/>?<sp/>-1.f<sp/>:<sp/>auc<sp/>&lt;<sp/>.6f<sp/>?<sp/>0.f<sp/>:<sp/>auc<sp/>&gt;=<sp/>.6<sp/>&amp;&amp;<sp/>auc<sp/>&lt;<sp/>.7f<sp/>?<sp/>1.f<sp/>:<sp/>auc<sp/>&gt;=<sp/>.7f<sp/>&amp;&amp;<sp/>auc<sp/>&lt;<sp/>.8f<sp/>?<sp/>2.f<sp/>:<sp/>3.f;});</highlight></codeline>
<codeline lineno="1139"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AUCI;</highlight></codeline>
<codeline lineno="1140"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1141"><highlight class="normal"></highlight></codeline>
<codeline lineno="1142"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a207c2c4eb2749fa8276ffaf809ed037c" kindref="member">get_AUCI</ref>;</highlight></codeline>
<codeline lineno="1143"><highlight class="normal"></highlight></codeline>
<codeline lineno="1162"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>GI(Gini<sp/>index)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1163"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1164"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>AUC,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1165"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1166"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>GI<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1167"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(AUC,<sp/>AUC<sp/>+<sp/>Nclass,<sp/>GI.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>auc){return<sp/>2.f<sp/>*<sp/>auc<sp/>-<sp/>1.f;});</highlight></codeline>
<codeline lineno="1168"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>GI;</highlight></codeline>
<codeline lineno="1169"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1170"><highlight class="normal"></highlight></codeline>
<codeline lineno="1171"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a7c3337082af672dcbd207c2be415909a" kindref="member">get_GI</ref>;</highlight></codeline>
<codeline lineno="1172"><highlight class="normal"></highlight></codeline>
<codeline lineno="1191"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>LS(Lift<sp/>score)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1192"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1193"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>PPV,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>PRE,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1194"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1195"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>LS<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1196"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(PPV,<sp/>PPV<sp/>+<sp/>Nclass,<sp/>PRE,<sp/>LS.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>ppv,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>pre){return<sp/>ppv<sp/>/<sp/>pre;});</highlight></codeline>
<codeline lineno="1197"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>LS;</highlight></codeline>
<codeline lineno="1198"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1199"><highlight class="normal"></highlight></codeline>
<codeline lineno="1200"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a387b17726f52083d971af993d49afd93" kindref="member">get_LS</ref>;</highlight></codeline>
<codeline lineno="1201"><highlight class="normal"></highlight></codeline>
<codeline lineno="1218"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>AM(Difference<sp/>between<sp/>automatic<sp/>and<sp/>manual<sp/>classification)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1219"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1220"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TOP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>P,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1221"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1222"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>AM<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1223"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TOP,<sp/>TOP<sp/>+<sp/>Nclass,<sp/>P,<sp/>AM.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>top,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>p){return<sp/>top<sp/>-<sp/>p;});</highlight></codeline>
<codeline lineno="1224"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AM;</highlight></codeline>
<codeline lineno="1225"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1226"><highlight class="normal"></highlight></codeline>
<codeline lineno="1227"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a141fc6ec94376c53ad4a16c1b92e3e08" kindref="member">get_AM</ref>;</highlight></codeline>
<codeline lineno="1228"><highlight class="normal"></highlight></codeline>
<codeline lineno="1249"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>OP(Optimized<sp/>precision)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1250"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1251"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>ACC,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1252"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1253"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>OP<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1254"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="1255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>OP[i]<sp/>=<sp/>ACC[i]<sp/>-<sp/>std<sp/>::<sp/>fabs(TNR[i]<sp/>-<sp/>TPR[i])<sp/>/<sp/>(TPR[i]<sp/>+<sp/>TNR[i]);</highlight></codeline>
<codeline lineno="1256"><highlight class="normal"></highlight></codeline>
<codeline lineno="1257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>OP;</highlight></codeline>
<codeline lineno="1258"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1259"><highlight class="normal"></highlight></codeline>
<codeline lineno="1260"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a579350c265a48baffbe7f289b387171e" kindref="member">get_OP</ref>;</highlight></codeline>
<codeline lineno="1261"><highlight class="normal"></highlight></codeline>
<codeline lineno="1278"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>IBA(Index<sp/>of<sp/>balanced<sp/>accuracy)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1279"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1280"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1281"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1282"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>IBA<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1283"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TPR,<sp/>TPR<sp/>+<sp/>Nclass,<sp/>TNR,<sp/>IBA.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tpr,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tnr){return<sp/>(1.f<sp/>+<sp/>tpr<sp/>-<sp/>tnr)<sp/>*<sp/>tpr<sp/>*<sp/>tnr;});</highlight></codeline>
<codeline lineno="1284"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>IBA;</highlight></codeline>
<codeline lineno="1285"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1286"><highlight class="normal"></highlight></codeline>
<codeline lineno="1287"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a2612ae8114244156e539072c7b7c2ab2" kindref="member">get_IBA</ref>;</highlight></codeline>
<codeline lineno="1288"><highlight class="normal"></highlight></codeline>
<codeline lineno="1304"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>GM(G-mean<sp/>geometric<sp/>mean<sp/>of<sp/>specificity<sp/>and<sp/>sensitivity)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1305"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1306"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1307"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1308"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>GM<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1309"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(TNR,<sp/>TNR<sp/>+<sp/>Nclass,<sp/>TPR,<sp/>GM.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tnr,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tpr){return<sp/>std<sp/>::<sp/>sqrt(tnr<sp/>*<sp/>tpr);});</highlight></codeline>
<codeline lineno="1310"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>GM;</highlight></codeline>
<codeline lineno="1311"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1312"><highlight class="normal"></highlight></codeline>
<codeline lineno="1313"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a4d1e9460a2d5f2ac1cfda99526cea5bd" kindref="member">get_GM</ref>;</highlight></codeline>
<codeline lineno="1314"><highlight class="normal"></highlight></codeline>
<codeline lineno="1334"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>Q(Yule<sp/>Q<sp/>-<sp/>coefficient<sp/>of<sp/>colligation)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1335"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1336"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1337"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1338"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>Q<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1339"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="1340"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>OR<sp/>=<sp/>(TP[i]<sp/>*<sp/>TN[i])<sp/>/<sp/>(FP[i]<sp/>*<sp/>FN[i]);</highlight></codeline>
<codeline lineno="1342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Q[i]<sp/>=<sp/>(OR<sp/>-<sp/>1.f)<sp/>/<sp/>(OR<sp/>+<sp/>1.f);</highlight></codeline>
<codeline lineno="1343"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1344"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Q;</highlight></codeline>
<codeline lineno="1345"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1346"><highlight class="normal"></highlight></codeline>
<codeline lineno="1347"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1afe2de8bdc7c11ea5f72841635345ba95" kindref="member">get_Q</ref>;</highlight></codeline>
<codeline lineno="1348"><highlight class="normal"></highlight></codeline>
<codeline lineno="1368"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>AGM(Adjusted<sp/>geometric<sp/>mean)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1369"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1370"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TNR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>GM,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>N,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>POP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1371"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1372"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>AGM<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1373"><highlight class="normal"></highlight></codeline>
<codeline lineno="1374"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="1375"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(POP[i]<sp/>!=<sp/>0.f)</highlight></codeline>
<codeline lineno="1377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AGM[i]<sp/>=<sp/>TPR[i]<sp/>==<sp/>0.f<sp/>?<sp/>0.f<sp/>:<sp/>(GM[i]<sp/>+<sp/>TNR[i]<sp/>*<sp/>N[i]<sp/>/<sp/>POP[i])<sp/>/<sp/>(1.f<sp/>+<sp/>N[i]<sp/>/<sp/>POP[i]);</highlight></codeline>
<codeline lineno="1379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AGM[i]<sp/>=<sp/>-1.f;</highlight></codeline>
<codeline lineno="1382"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1383"><highlight class="normal"></highlight></codeline>
<codeline lineno="1384"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AGM;</highlight></codeline>
<codeline lineno="1385"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1386"><highlight class="normal"></highlight></codeline>
<codeline lineno="1387"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1ab0aed095be67e408618aa5545f20df07" kindref="member">get_AGM</ref>;</highlight></codeline>
<codeline lineno="1388"><highlight class="normal"></highlight></codeline>
<codeline lineno="1407"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>MCCI(Matthews<sp/>correlation<sp/>coefficient<sp/>interpretation)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1408"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1409"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>MCC,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1410"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1411"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>MCCI<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1412"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(MCC,<sp/>MCC<sp/>+<sp/>Nclass,<sp/>MCCI.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>mcc){return<sp/>std<sp/>::<sp/>isnan(mcc)<sp/>||<sp/>std<sp/>::<sp/>isinf(mcc)<sp/>?<sp/>-1.f<sp/>:<sp/>mcc<sp/>&lt;<sp/>.3f<sp/>?<sp/>0.f<sp/>:<sp/>mcc<sp/>&gt;=<sp/>.3f<sp/>&amp;&amp;<sp/>mcc<sp/>&lt;<sp/>.5f<sp/>?<sp/>1.f<sp/>:<sp/>mcc<sp/>&gt;=<sp/>.5f<sp/>&amp;&amp;<sp/>mcc<sp/>&lt;<sp/>.7f<sp/>?<sp/>2.f<sp/>:<sp/>mcc<sp/>&gt;=<sp/>.7<sp/>&amp;&amp;<sp/>mcc<sp/>&lt;<sp/>.9f<sp/>?<sp/>3.f<sp/>:<sp/>4.f;});</highlight></codeline>
<codeline lineno="1413"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MCCI;</highlight></codeline>
<codeline lineno="1414"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1415"><highlight class="normal"></highlight></codeline>
<codeline lineno="1416"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1aa462ac02b23fa3e6ca3c7dceb1abee09" kindref="member">get_MCCI</ref>;</highlight></codeline>
<codeline lineno="1417"><highlight class="normal"></highlight></codeline>
<codeline lineno="1442"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>AGF(Adjusted<sp/>F-score)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1443"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1444"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>FN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TN,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1445"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1446"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>AGF<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="1448"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>F2<sp/>=<sp/>(5.f<sp/>*<sp/>TP[i])<sp/>/<sp/>(5.f<sp/>*<sp/>TP[i]<sp/>+<sp/>FP[i]<sp/>+<sp/>4.f<sp/>*<sp/>FN[i]);</highlight></codeline>
<codeline lineno="1450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>F05_inv<sp/>=<sp/>(1.25f<sp/>*<sp/>TN[i])<sp/>/<sp/>(1.25f<sp/>*<sp/>TN[i]<sp/>+<sp/>FN[i]<sp/>+<sp/>.25f<sp/>*<sp/>FP[i]);</highlight></codeline>
<codeline lineno="1451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>AGF[i]<sp/>=<sp/>std<sp/>::<sp/>sqrt(F2<sp/>*<sp/>F05_inv);</highlight></codeline>
<codeline lineno="1452"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1453"><highlight class="normal"></highlight></codeline>
<codeline lineno="1454"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AGF;</highlight></codeline>
<codeline lineno="1455"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1456"><highlight class="normal"></highlight></codeline>
<codeline lineno="1457"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a842f9ac840fb456cac90959e50711daa" kindref="member">get_AGF</ref>;</highlight></codeline>
<codeline lineno="1458"><highlight class="normal"></highlight></codeline>
<codeline lineno="1478"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>OC(Overlap<sp/>coefficient)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1479"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1480"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TOP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>P,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1481"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1482"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>OC<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1483"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="1484"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>OC[i]<sp/>=<sp/>TP[i]<sp/>/<sp/>std<sp/>::<sp/>min(TOP[i],<sp/>P[i]);</highlight></codeline>
<codeline lineno="1486"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1487"><highlight class="normal"></highlight></codeline>
<codeline lineno="1488"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>OC;</highlight></codeline>
<codeline lineno="1489"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1490"><highlight class="normal"></highlight></codeline>
<codeline lineno="1491"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a52758992ba041cfa0b006caab2bb2fda" kindref="member">get_OC</ref>;</highlight></codeline>
<codeline lineno="1492"><highlight class="normal"></highlight></codeline>
<codeline lineno="1513"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>OOC(Otsuka-Ochiai<sp/>coefficient)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1514"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1515"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TOP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>P,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1516"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1517"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>OOC<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1518"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>Nclass;<sp/>++i)</highlight></codeline>
<codeline lineno="1519"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="1520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>OOC[i]<sp/>=<sp/>TP[i]<sp/>/<sp/>std<sp/>::<sp/>sqrt(TOP[i]<sp/>*<sp/>P[i]);</highlight></codeline>
<codeline lineno="1521"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1522"><highlight class="normal"></highlight></codeline>
<codeline lineno="1523"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>OOC;</highlight></codeline>
<codeline lineno="1524"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1525"><highlight class="normal"></highlight></codeline>
<codeline lineno="1526"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a4b0d8881921f0084de34f7f8613ece90" kindref="member">get_OOC</ref>;</highlight></codeline>
<codeline lineno="1527"><highlight class="normal"></highlight></codeline>
<codeline lineno="1545"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>AUPR(Area<sp/>under<sp/>the<sp/>PR<sp/>curve)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1546"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1547"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>PPV,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TPR,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1548"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1549"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>AUPR<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1550"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(PPV,<sp/>PPV<sp/>+<sp/>Nclass,<sp/>TPR,<sp/>AUPR.get(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>ppv,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>tpr){return<sp/>(ppv<sp/>+<sp/>tpr)<sp/>*<sp/>.5f;});</highlight></codeline>
<codeline lineno="1551"><highlight class="normal"></highlight></codeline>
<codeline lineno="1552"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AUPR;</highlight></codeline>
<codeline lineno="1553"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1554"><highlight class="normal"></highlight></codeline>
<codeline lineno="1555"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a09d309212b0d0d11c991f5051a0ef5c8" kindref="member">get_AUPR</ref>;</highlight></codeline>
<codeline lineno="1556"><highlight class="normal"></highlight></codeline>
<codeline lineno="1575"><highlight class="keyword">struct<sp/></highlight><highlight class="comment">//<sp/>BCD(Bray-Curtis<sp/>dissimilarity)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1576"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1577"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>operator()<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>TOP,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>P,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*<sp/>AM,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>&amp;<sp/>Nclass)</highlight></codeline>
<codeline lineno="1578"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="1579"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>unique_ptr<sp/>&lt;<sp/>float[]<sp/>&gt;<sp/>BCD<sp/>(</highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal">[Nclass]);</highlight></codeline>
<codeline lineno="1580"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>s<sp/>=<sp/>std<sp/>::<sp/>accumulate(TOP,<sp/>TOP<sp/>+<sp/>Nclass,<sp/>0.f)<sp/>+<sp/>std<sp/>::<sp/>accumulate(P,<sp/>P<sp/>+<sp/>Nclass,<sp/>0.f);</highlight></codeline>
<codeline lineno="1581"><highlight class="normal"><sp/><sp/><sp/><sp/>std<sp/>::<sp/>transform(AM,<sp/>AM<sp/>+<sp/>Nclass,<sp/>BCD.get(),<sp/>[&amp;](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>&amp;<sp/>am){return<sp/>std<sp/>::<sp/>fabs(am)<sp/>/<sp/>s;});</highlight></codeline>
<codeline lineno="1582"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>BCD;</highlight></codeline>
<codeline lineno="1583"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="1584"><highlight class="normal"></highlight></codeline>
<codeline lineno="1585"><highlight class="normal">}<sp/><ref refid="class__stats_8h_1a82d6e3abbb345428912773e5dbcf8816" kindref="member">get_BCD</ref>;</highlight></codeline>
<codeline lineno="1586"><highlight class="normal"></highlight></codeline>
<codeline lineno="1587"><highlight class="normal"></highlight></codeline>
<codeline lineno="1588"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/>//<sp/>__class_stats_h__</highlight></codeline>
    </programlisting>
    <location file="/home/nico/Code/scorer/include/class_stats.h"/>
  </compounddef>
</doxygen>
